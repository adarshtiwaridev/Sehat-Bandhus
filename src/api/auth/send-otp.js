// This endpoint uses Firebase Identity Toolkit REST API to request
// a phone verification SMS. The client must provide a reCAPTCHA token
// generated by Firebase RecaptchaVerifier (appVerifier.verify()).

// export default async function handler(req, res) {
//   if (req.method !== 'POST') return res.status(405).json({ message: 'Method not allowed' });

//   const { mobile, recaptchaToken } = req.body;
//   if (!mobile) return res.status(400).json({ message: 'Mobile number is required' });
//   if (!recaptchaToken) return res.status(400).json({ message: 'recaptchaToken is required' });

//   const apiKey = process.env.FIREBASE_API_KEY;
//   if (!apiKey) return res.status(500).json({ message: 'FIREBASE_API_KEY not configured on server' });

//   try {
//     const resp = await fetch(`https://identitytoolkit.googleapis.com/v1/accounts:sendVerificationCode?key=${apiKey}`, {
//       method: 'POST',
//       headers: { 'Content-Type': 'application/json' },
//       body: JSON.stringify({ phoneNumber: `+${mobile.replace(/^\+/, '')}`, recaptchaToken }),
//     });

//     const data = await resp.json();
//     if (!resp.ok) {
//       console.error('Firebase sendVerificationCode error', data);
//       return res.status(500).json({ message: 'Failed to request verification code', error: data });
//     }

//     // data.sessionInfo is required to verify the code later
//     return res.status(200).json({ message: 'OTP sent via Firebase', sessionInfo: data.sessionInfo });
//   } catch (err) {
//     console.error('send-otp error', err);
//     return res.status(500).json({ message: 'Server error', error: err.message });
//   }
// }


// /pages/api/auth/send-otp.js
import { sendOTPEmail } from "@/lib/nodemailer"; // move your nodemailer logic here
 import Otp from "@/models/Otp";
import connectDB from "@/lib/dbConnect";
let otpStore = {}; // temporary memory (use DB/Redis in production)

export default async function handler(req, res) {
  if (req.method !== "POST")
    return res.status(405).json({ message: "Method not allowed" });

  await connectDB(); // âœ… connect to MongoDB

  const { email,mobile } = req.body;
  if (!email) return res.status(400).json({ message: "Email is required" });

  try {
    // Generate 6-digit random OTP
    const otp = Math.floor(100000 + Math.random() * 900000).toString();

    // Delete any existing OTP for same email before saving new one
    await Otp.deleteMany({ email });

    // Save OTP in MongoDB (expires automatically after 5 mins)
    await Otp.create({
      mobile,
      email,
      otp,
      createdAt: new Date(),
    });

    // Send OTP to email
    await sendOTPEmail(email, otp);

    return res
      .status(200)
      .json({ message: "OTP sent to email successfully", email });
  } catch (error) {
    console.error("Error sending OTP:", error);
    return res
      .status(500)
      .json({ message: "Failed to send OTP", error: error.message });
  }
}
 
